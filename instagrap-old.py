import os
import logging
import requests
import re
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext, CallbackQueryHandler
import json
import asyncio
import aiohttp
from urllib.parse import urlparse
import tempfile
import glob
import shutil
import time
from instagrapi import Client
from instagrapi.exceptions import LoginRequired
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Bot configuration
class Config:
    TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
    INSTAGRAM_USERNAME = os.getenv('INSTAGRAM_USERNAME')
    INSTAGRAM_PASSWORD = os.getenv('INSTAGRAM_PASSWORD')
    DOWNLOAD_DIR = "instagram_downloads"

    @classmethod
    def validate(cls):
        missing = []
        if not cls.TOKEN:
            missing.append('TELEGRAM_BOT_TOKEN')
        if not cls.INSTAGRAM_USERNAME:
            missing.append('INSTAGRAM_USERNAME')
        if not cls.INSTAGRAM_PASSWORD:
            missing.append('INSTAGRAM_PASSWORD')

        if missing:
            raise ValueError(f"Missing required environment variables: {', '.join(missing)}\n"
                           f"Please create a .env file with the following variables:\n"
                           f"TELEGRAM_BOT_TOKEN=your_token\n"
                           f"INSTAGRAM_USERNAME=your_username\n"
                           f"INSTAGRAM_PASSWORD=your_password")

# Instagram URL pattern
INSTAGRAM_URL_PATTERN = r'https?://(?:www\.)?instagram\.com/(?:p|reel|stories|s)/([^/?]+)(?:/([^/?]+))?'

# Th∆∞ m·ª•c l∆∞u tr·ªØ
DOWNLOAD_DIR = Config.DOWNLOAD_DIR
os.makedirs(DOWNLOAD_DIR, exist_ok=True)

# Instagram client
cl = Client()
cl.delay_range = [1, 3]  # Delay gi·ªØa c√°c request

def init_instagram_client():
    """Initialize Instagram client with login and session management.

    Returns:
        bool: True if initialization successful, False otherwise

    Raises:
        LoginError: If login fails
        SessionError: If session cannot be loaded/saved
    """
    try:
        Config.validate()
        session_file = "instagram_session.json"

        if os.path.exists(session_file):
            try:
                cl.load_settings(session_file)
                cl.get_timeline_feed()
                logger.info("Loaded existing Instagram session")
                return True
            except Exception as e:
                logger.warning(f"Existing session invalid: {e}")

        cl.login(Config.INSTAGRAM_USERNAME, Config.INSTAGRAM_PASSWORD)
        cl.dump_settings(session_file)
        logger.info("Created new Instagram session")
        return True

    except Exception as e:
        logger.error(f"Failed to initialize Instagram client: {e}")
        return False

async def download_instagram_content(shortcode: str) -> list:
    """Download Instagram content using instagrapi"""
    media_files = []
    try:
        # Get media ID from shortcode
        media_pk = cl.media_pk_from_code(shortcode)

        # Get media info
        media_info = cl.media_info(media_pk)
        username = media_info.user.username

        # L·∫•y caption v√† lo·∫°i b·ªè hashtag
        caption = media_info.caption_text if media_info.caption_text else "Kh√¥ng c√≥ caption"
        # Remove hashtags using regex
        caption = re.sub(r'#\w+', '', caption).strip()

        posted_at = media_info.taken_at.strftime("%H:%M %d/%m/%Y")

        # T·∫°o th√¥ng tin chi ti·∫øt v·ªÅ b√†i vi·∫øt v·ªõi n√∫t b·∫•m username
        post_info = (
            f"üìù Caption: {caption}\n\n"
            f"üë§ Posted by: @{username}\n"
            f"üïí Posted at: {posted_at}"
        )

        # T·∫°o keyboard v·ªõi n√∫t b·∫•m username
        keyboard = [[InlineKeyboardButton(
            text=f"@{username}",
            url=f"https://instagram.com/{username}"
        )]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        # Create directory for this post
        target_dir = os.path.join(DOWNLOAD_DIR, shortcode)
        os.makedirs(target_dir, exist_ok=True)

        if media_info.media_type == 1:  # Photo
            # Download photo
            photo_path = cl.photo_download(media_pk, target_dir)
            photo_path_str = str(photo_path)
            media_files.append({
                "path": photo_path_str,
                "type": "image",
                "username": username,  # Th√™m username v√†o media_files
                "media_info": media_info  # Th√™m to√†n b·ªô media_info
            })

        elif media_info.media_type == 2:  # Video
            try:
                # L·∫•y URL video ch·∫•t l∆∞·ª£ng cao nh·∫•t t·ª´ resources
                video_url = None
                max_width = 0

                # Ki·ªÉm tra resources tr∆∞·ªõc
                if hasattr(media_info, 'resources') and media_info.resources:
                    for resource in media_info.resources:
                        if hasattr(resource, 'video_url') and resource.video_url:
                            if hasattr(resource, 'width') and resource.width > max_width:
                                video_url = resource.video_url
                                max_width = resource.width

                # N·∫øu kh√¥ng c√≥ trong resources, th·ª≠ l·∫•y t·ª´ video_versions
                if not video_url and hasattr(media_info, 'video_versions'):
                    for version in media_info.video_versions:
                        if version.width > max_width:
                            video_url = version.url
                            max_width = version.width

                # Fallback to default video_url if still not found
                if not video_url:
                    video_url = media_info.video_url

                if video_url:
                    file_name = f"{shortcode}.mp4"
                    file_path = os.path.join(target_dir, file_name)

                    # TƒÉng timeout cho video d√†i
                    response = requests.get(video_url, stream=True, timeout=30)
                    if response.status_code == 200:
                        with open(file_path, 'wb') as f:
                            for chunk in response.iter_content(chunk_size=8192):
                                if chunk:
                                    f.write(chunk)
                        media_files.append({
                            "path": file_path,
                            "type": "video",
                            "username": username,
                            "media_info": media_info,
                            "quality": f"{max_width}p"  # Th√™m th√¥ng tin ƒë·ªô ph√¢n gi·∫£i
                        })
                        logger.info(f"ƒê√£ t·∫£i video ch·∫•t l∆∞·ª£ng cao {max_width}p: {file_path}")
                    else:
                        raise Exception(f"Kh√¥ng th·ªÉ t·∫£i video (HTTP {response.status_code})")
                else:
                    raise Exception("Kh√¥ng t√¨m th·∫•y URL video ch·∫•t l∆∞·ª£ng cao")

            except Exception as e:
                logger.error(f"L·ªói khi t·∫£i video ch·∫•t l∆∞·ª£ng cao: {e}")
                # Fallback: s·ª≠ d·ª•ng ph∆∞∆°ng th·ª©c t·∫£i th√¥ng th∆∞·ªùng
                try:
                    video_path = cl.video_download(media_pk, target_dir)
                    if video_path and os.path.exists(str(video_path)):
                        new_path = os.path.join(target_dir, file_name)
                        os.rename(str(video_path), new_path)
                        media_files.append({
                            "path": new_path,
                            "type": "video",
                            "username": username,
                            "media_info": media_info
                        })
                        logger.info(f"ƒê√£ t·∫£i story d·ª± ph√≤ng: {file_name}")
                except Exception as backup_error:
                    logger.error(f"L·ªói khi t·∫£i story d·ª± ph√≤ng {file_name}: {backup_error}")

        elif media_info.media_type == 8:  # Album
            # Download all items in album
            album_files = cl.album_download(media_pk, target_dir)
            for file_path in album_files:
                file_path_str = str(file_path)
                if file_path_str.endswith('.mp4'):
                    # Th·ª≠ t·∫£i l·∫°i video v·ªõi ch·∫•t l∆∞·ª£ng cao
                    try:
                        video_url = cl.media_info(media_pk).video_url
                        if video_url:
                            response = requests.get(video_url, stream=True)
                            if response.status_code == 200:
                                with open(file_path_str, 'wb') as f:
                                    for chunk in response.iter_content(chunk_size=8192):
                                        if chunk:
                                            f.write(chunk)
                                logger.info(f"ƒê√£ t·∫£i l·∫°i video album v·ªõi ch·∫•t l∆∞·ª£ng cao: {file_path_str}")
                    except Exception as e:
                        logger.error(f"Kh√¥ng th·ªÉ t·∫£i l·∫°i video album ch·∫•t l∆∞·ª£ng cao: {e}")
                    media_files.append({
                        "path": file_path_str,
                        "type": "video",
                        "username": username,  # Th√™m username v√†o media_files
                        "media_info": media_info  # Th√™m to√†n b·ªô media_info
                    })
                else:
                    media_files.append({
                        "path": file_path_str,
                        "type": "image",
                        "username": username,  # Th√™m username v√†o media_files
                        "media_info": media_info  # Th√™m to√†n b·ªô media_info
                    })

        logger.info(f"Downloaded {len(media_files)} files from {shortcode}")

        # Verify all files exist and are not empty
        valid_files = []
        for media_file in media_files:
            file_path = media_file["path"]
            if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
                valid_files.append(media_file)
                logger.info(f"Verified file: {file_path}")
            else:
                logger.error(f"Invalid or empty file: {file_path}")

        # Th√™m th√¥ng tin b√†i vi·∫øt v√†o media_files ƒë·∫ßu ti√™n
        if valid_files:
            valid_files[0]["post_info"] = post_info

        return valid_files

    except LoginRequired:
        logger.error("Login required, trying to re-login")
        if init_instagram_client():
            # Retry once after re-login
            return await download_instagram_content(shortcode)
        return []
    except Exception as e:
        logger.error(f"Error downloading content: {e}")
        return []

async def download_instagram_story(username: str, story_id: str = None) -> list:
    """Download Instagram story using instagrapi"""
    media_files = []
    processed_ids = set()
    try:
        # L·∫•y user ID t·ª´ username
        user_id = cl.user_id_from_username(username)

        # T·∫°o th∆∞ m·ª•c cho stories
        target_dir = os.path.join(DOWNLOAD_DIR, f"stories_{username}")
        os.makedirs(target_dir, exist_ok=True)

        # L·∫•y danh s√°ch stories
        stories = cl.user_stories(user_id)

        if not stories:
            logger.error(f"Kh√¥ng t√¨m th·∫•y story n√†o c·ªßa {username}")
            return []

        logger.info(f"T√¨m th·∫•y {len(stories)} story c·ªßa {username}")

        # S·∫Øp x·∫øp stories theo th·ªùi gian ƒë·ªÉ t·∫£i theo th·ª© t·ª±
        sorted_stories = sorted(stories, key=lambda x: x.taken_at)

        for story in sorted_stories:
            # N·∫øu c√≥ story_id c·ª• th·ªÉ, ch·ªâ t·∫£i story ƒë√≥
            if story_id and str(story.pk) != story_id:
                continue

            # Ki·ªÉm tra story ID ƒë√£ x·ª≠ l√Ω ch∆∞a
            if story.pk in processed_ids:
                logger.info(f"Story {story.pk} ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω tr∆∞·ªõc ƒë√≥")
                continue

            processed_ids.add(story.pk)

            try:
                timestamp = story.taken_at.strftime("%Y%m%d_%H%M%S")

                if story.media_type == 1:  # Photo
                    file_name = f"story_{username}_{timestamp}_{story.pk}.jpg"
                    file_path = os.path.join(target_dir, file_name)

                    if os.path.exists(file_path):
                        logger.info(f"File {file_name} ƒë√£ t·ªìn t·∫°i, b·ªè qua")
                        continue

                    # L·∫•y URL ch·∫•t l∆∞·ª£ng cao nh·∫•t cho ·∫£nh
                    photo_url = story.thumbnail_url_info()[-1]['url']
                    response = requests.get(photo_url)
                    if response.status_code == 200:
                        with open(file_path, 'wb') as f:
                            f.write(response.content)
                        media_files.append({
                            "path": file_path,
                            "type": "image",
                            "taken_at": story.taken_at,
                            "username": username
                        })
                        logger.info(f"ƒê√£ t·∫£i story ·∫£nh ch·∫•t l∆∞·ª£ng cao: {story.pk} - {file_name}")

                elif story.media_type == 2:  # Video
                    file_name = f"story_{username}_{timestamp}_{story.pk}.mp4"
                    file_path = os.path.join(target_dir, file_name)

                    if os.path.exists(file_path):
                        logger.info(f"File {file_name} ƒë√£ t·ªìn t·∫°i, b·ªè qua")
                        continue

                    # L·∫•y URL video ch·∫•t l∆∞·ª£ng cao nh·∫•t
                    video_url = story.video_url
                    response = requests.get(video_url)
                    if response.status_code == 200:
                        with open(file_path, 'wb') as f:
                            f.write(response.content)
                        media_files.append({
                            "path": file_path,
                            "type": "video",
                            "taken_at": story.taken_at,
                            "username": username
                        })
                        logger.info(f"ƒê√£ t·∫£i story video ch·∫•t l∆∞·ª£ng cao: {story.pk} - {file_name}")

            except Exception as e:
                logger.error(f"L·ªói khi t·∫£i story {story.pk}: {e}")
                # N·∫øu t·∫£i ch·∫•t l∆∞·ª£ng cao th·∫•t b·∫°i, th·ª≠ t·∫£i b·∫±ng ph∆∞∆°ng th·ª©c th√¥ng th∆∞·ªùng
                try:
                    story_path = cl.story_download(story.pk, folder=target_dir)
                    if story_path and os.path.exists(str(story_path)):
                        new_path = os.path.join(target_dir, file_name)
                        os.rename(str(story_path), new_path)
                        media_files.append({
                            "path": new_path,
                            "type": "video" if story.media_type == 2 else "image",
                            "taken_at": story.taken_at,
                            "username": username
                        })
                        logger.info(f"ƒê√£ t·∫£i story d·ª± ph√≤ng: {story.pk} - {file_name}")
                except Exception as backup_error:
                    logger.error(f"L·ªói khi t·∫£i story d·ª± ph√≤ng {story.pk}: {backup_error}")
                continue

        # S·∫Øp x·∫øp media_files theo th·ªùi gian ƒëƒÉng
        media_files.sort(key=lambda x: x["taken_at"])

        # Ki·ªÉm tra v√† x√°c th·ª±c c√°c file ƒë√£ t·∫£i
        valid_files = []
        for media_file in media_files:
            file_path = media_file["path"]
            if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
                valid_files.append(media_file)
                logger.info(f"ƒê√£ x√°c th·ª±c file: {file_path}")
            else:
                logger.error(f"File kh√¥ng h·ª£p l·ªá ho·∫∑c r·ªóng: {file_path}")

        return valid_files

    except Exception as e:
        logger.error(f"L·ªói khi t·∫£i stories: {e}")
        return []

async def process_instagram_url(update: Update, context: CallbackContext) -> None:
    """Process Instagram URL and send media."""
    url = update.message.text.strip()

    if not re.match(INSTAGRAM_URL_PATTERN, url):
        await update.message.reply_text("Vui l√≤ng g·ª≠i URL Instagram h·ª£p l·ªá.")
        return

    processing_message = await update.message.reply_text("‚åõ ƒêang x·ª≠ l√Ω...")

    try:
        # Extract information from URL
        match = re.search(INSTAGRAM_URL_PATTERN, url)
        first_part = match.group(1)
        second_part = match.group(2) if match.group(2) else None

        await processing_message.edit_text("üîç ƒêang ki·ªÉm tra URL...")

        # X√°c ƒë·ªãnh lo·∫°i n·ªôi dung v√† t·∫£i xu·ªëng
        if 'stories' in url or '/s/' in url:
            # URL l√† story
            username = first_part
            story_id = second_part
            await processing_message.edit_text(f"üì• ƒêang t·∫£i story c·ªßa @{username}...")
            media_items = await download_instagram_story(username, story_id)

            if media_items:
                await processing_message.edit_text(f"‚úÖ ƒê√£ t√¨m th·∫•y {len(media_items)} story t·ª´ @{username}\n‚åõ ƒêang chu·∫©n b·ªã g·ª≠i...")
            else:
                await processing_message.edit_text(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y story n√†o t·ª´ @{username}")
                return
        else:
            # URL l√† post ho·∫∑c reel b√¨nh th∆∞·ªùng
            shortcode = first_part
            await processing_message.edit_text("üîç ƒêang ki·ªÉm tra n·ªôi dung...")

            # L·∫•y th√¥ng tin username tr∆∞·ªõc
            try:
                media_pk = cl.media_pk_from_code(shortcode)
                media_info = cl.media_info(media_pk)
                username = media_info.user.username
                await processing_message.edit_text(f"üì• ƒêang t·∫£i n·ªôi dung c·ªßa @{username}...")
            except Exception as e:
                logger.error(f"L·ªói khi l·∫•y th√¥ng tin username: {e}")
                await processing_message.edit_text("üì• ƒêang t·∫£i n·ªôi dung...")

            media_items = await download_instagram_content(shortcode)

        if not media_items:
            await processing_message.edit_text("‚ö†Ô∏è Kh√¥ng th·ªÉ t·∫£i xu·ªëng. Nguy√™n nh√¢n c√≥ th·ªÉ:\n"
                                            "‚Ä¢ B√†i vi·∫øt ƒë√£ b·ªã x√≥a\n"
                                            "‚Ä¢ T√†i kho·∫£n ri√™ng t∆∞\n"
                                            "‚Ä¢ Story ƒë√£ h·∫øt h·∫°n\n"
                                            "‚Ä¢ Instagram ƒëang gi·ªõi h·∫°n truy c·∫≠p")
            return

        # G·ª≠i th√¥ng tin b√†i vi·∫øt v·ªõi n√∫t b·∫•m
        if media_items and "post_info" in media_items[0]:
            keyboard = [[InlineKeyboardButton(
                text=f"@{media_items[0]['username']}",
                url=f"https://instagram.com/{media_items[0]['username']}"
            )]]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await update.message.reply_text(
                media_items[0]["post_info"],
                reply_markup=reply_markup
            )

        await processing_message.edit_text(f"üì§ ƒêang g·ª≠i {len(media_items)} file...")

        success_videos = 0
        success_images = 0
        processed_files = set()  # L∆∞u tr·ªØ ƒë∆∞·ªùng d·∫´n c√°c file ƒë√£ x·ª≠ l√Ω

        for i, media_item in enumerate(media_items):
            try:
                file_path = media_item["path"]
                media_type = media_item["type"]

                logger.info(f"X·ª≠ l√Ω file {i+1}/{len(media_items)}")
                logger.info(f"ƒê∆∞·ªùng d·∫´n: {file_path}")
                logger.info(f"Lo·∫°i file: {media_type}")

                if not os.path.exists(file_path):
                    logger.error(f"File kh√¥ng t·ªìn t·∫°i: {file_path}")
                    continue

                file_size = os.path.getsize(file_path)
                if file_size == 0:
                    logger.error(f"File r·ªóng: {file_path}")
                    continue

                logger.info(f"B·∫Øt ƒë·∫ßu g·ª≠i file {file_path} (size: {file_size} bytes)")

                try:
                    with open(file_path, 'rb') as file:
                        # T·∫°o t√™n file v·ªõi username, shortcode v√† s·ªë th·ª© t·ª±
                        if 'stories' in file_path:
                            # ƒê·ªëi v·ªõi story, l·∫•y username v√† t√≠nh th·ªùi gian ƒë√£ ƒëƒÉng
                            username = media_item.get("username", "unknown")
                            taken_at = media_item.get("taken_at")

                            # T√≠nh s·ªë gi·ªù ƒë√£ tr√¥i qua
                            time_diff = time.time() - taken_at.timestamp()
                            hours_ago = int(time_diff / 3600)

                            # T·∫°o chu·ªói th·ªùi gian
                            if hours_ago == 0:
                                time_str = "Just now"
                            elif hours_ago == 1:
                                time_str = "1H ago"
                            else:
                                time_str = f"{hours_ago}H ago"

                            # Ch·ªâ th√™m s·ªë th·ª© t·ª± n·∫øu c√≥ nhi·ªÅu story
                            if len(media_items) > 1:
                                filename = f"story_{i+1}.{'mp4' if media_type == 'video' else 'jpg'}"
                                caption = f"{media_type.capitalize()} {i+1}/{len(media_items)}\nüïí {time_str}"
                            else:
                                filename = f"story.{'mp4' if media_type == 'video' else 'jpg'}"
                                caption = f"{media_type.capitalize()}\nüïí {time_str}"

                            # G·ª≠i file v·ªõi caption
                            if media_type == "video":
                                await update.message.reply_document(
                                    document=file,
                                    filename=filename,
                                    caption=caption,
                                    read_timeout=300,
                                    write_timeout=300,
                                    connect_timeout=60,
                                    disable_content_type_detection=True
                                )
                                success_videos += 1
                                processed_files.add(file_path)  # Add to processed files for deletion
                                logger.info(f"ƒê√£ g·ª≠i th√†nh c√¥ng video {i+1}")
                            else:  # image
                                await update.message.reply_document(
                                    document=file,
                                    filename=filename,
                                    caption=caption,
                                    read_timeout=120,
                                    write_timeout=120,
                                    connect_timeout=60
                                )
                                success_images += 1
                                processed_files.add(file_path)  # Add to processed files for deletion
                                logger.info(f"ƒê√£ g·ª≠i th√†nh c√¥ng ·∫£nh {i+1}")
                        else:
                            # ƒê·ªëi v·ªõi post th∆∞·ªùng
                            username = media_item.get("username", "unknown")
                            shortcode = first_part
                            if len(media_items) > 1:
                                filename = f"{shortcode}_{i+1}.{'mp4' if media_type == 'video' else 'jpg'}"
                                caption = f"{media_type.capitalize()} {i+1}/{len(media_items)}"
                            else:
                                filename = f"{shortcode}.{'mp4' if media_type == 'video' else 'jpg'}"
                                caption = f"{media_type.capitalize()}"

                            # G·ª≠i file v·ªõi caption
                            if media_type == "video":
                                await update.message.reply_document(
                                    document=file,
                                    filename=filename,
                                    caption=caption,
                                    read_timeout=300,
                                    write_timeout=300,
                                    connect_timeout=60,
                                    disable_content_type_detection=True
                                )
                                success_videos += 1
                                processed_files.add(file_path)  # Add to processed files for deletion
                                logger.info(f"ƒê√£ g·ª≠i th√†nh c√¥ng video {i+1}")
                            else:  # image
                                await update.message.reply_document(
                                    document=file,
                                    filename=filename,
                                    caption=caption,
                                    read_timeout=120,
                                    write_timeout=120,
                                    connect_timeout=60
                                )
                                success_images += 1
                                processed_files.add(file_path)  # Add to processed files for deletion
                                logger.info(f"ƒê√£ g·ª≠i th√†nh c√¥ng ·∫£nh {i+1}")
                except Exception as send_error:
                    logger.error(f"L·ªói khi g·ª≠i file {file_path}: {send_error}")
            except Exception as e:
                logger.error(f"L·ªói khi x·ª≠ l√Ω file {i+1}: {e}")

        # X√≥a c√°c file ƒë√£ g·ª≠i th√†nh c√¥ng
        for file_path in processed_files:
            try:
                os.remove(file_path)
                logger.info(f"ƒê√£ x√≥a file: {file_path}")
            except Exception as e:
                logger.error(f"L·ªói khi x√≥a file {file_path}: {e}")

        # X√≥a th∆∞ m·ª•c c·ªßa b√†i ƒëƒÉng n·∫øu tr·ªëng
        if 'stories' in url or '/s/' in url:
            post_dir = os.path.join(DOWNLOAD_DIR, f"stories_{first_part}")
        else:
            post_dir = os.path.join(DOWNLOAD_DIR, first_part)

        try:
            if os.path.exists(post_dir) and not os.listdir(post_dir):
                os.rmdir(post_dir)
                logger.info(f"ƒê√£ x√≥a th∆∞ m·ª•c r·ªóng: {post_dir}")
        except Exception as e:
            logger.error(f"L·ªói khi x√≥a th∆∞ m·ª•c {post_dir}: {e}")

        if success_videos > 0 or success_images > 0:
            status_message = []
            if success_videos > 0:
                status_message.append(f"üëâ {success_videos} video")
            if success_images > 0:
                status_message.append(f"üëâ {success_images} h√¨nh ·∫£nh")

            # Th√™m username v√†o th√¥ng b√°o th√†nh c√¥ng
            if 'stories' in url or '/s/' in url:
                await processing_message.edit_text(f"‚úÖ T·∫£i xu·ªëng story c·ªßa @{username} th√†nh c√¥ng!\n\n" + "\n".join(status_message))
            else:
                # Ph√¢n bi·ªát gi·ªØa post v√† reel
                content_type = "reel üì±" if "reel" in url else "post üìë"
                await processing_message.edit_text(f"‚úÖ T·∫£i xu·ªëng {content_type} c·ªßa @{username} th√†nh c√¥ng!\n\n" + "\n".join(status_message))
        else:
            await processing_message.edit_text("‚ùå Kh√¥ng th·ªÉ t·∫£i l√™n n·ªôi dung")

    except Exception as e:
        logger.error(f"L·ªói x·ª≠ l√Ω URL Instagram: {e}")
        await processing_message.edit_text(f"‚ùå ƒê√£ x·∫£y ra l·ªói: {str(e)}\nVui l√≤ng th·ª≠ l·∫°i sau.")

async def start(update: Update, context: CallbackContext) -> None:
    """Send a message when the command /start is issued."""
    await update.message.reply_text(
        "üëã Ch√†o m·ª´ng ƒë·∫øn v·ªõi Bot T·∫£i xu·ªëng Instagram!\n\n"
        "G·ª≠i cho t√¥i URL b√†i ƒëƒÉng, video ng·∫Øn Instagram, v√† t√¥i s·∫Ω t·∫£i xu·ªëng cho b·∫°n.\n\n"
        "V√≠ d·ª•: https://www.instagram.com/p/XXXX/"
    )

async def help_command(update: Update, context: CallbackContext, return_text: bool = False) -> None:
    """Send a message when the command /help is issued."""
    text = ("üìñ *C√°ch s·ª≠ d·ª•ng bot n√†y:*\n\n"
            "1. Sao ch√©p URL Instagram\n"
            "2. G·ª≠i URL ƒë·∫øn bot n√†y\n"
            "3. ƒê·ª£i bot x·ª≠ l√Ω v√† t·∫£i xu·ªëng\n\n"
            "_L∆∞u √Ω: Stories ch·ªâ t·ªìn t·∫°i trong 24 gi·ªù v√† c√≥ th·ªÉ y√™u c·∫ßu theo d√µi t√†i kho·∫£n._\n\n"
            "N·∫øu b·∫°n g·∫∑p b·∫•t k·ª≥ v·∫•n ƒë·ªÅ n√†o, vui l√≤ng th·ª≠ l·∫°i sau.")

    if return_text:
        return text

    await update.message.reply_text(
        text,
        parse_mode='Markdown',
        reply_markup=InlineKeyboardMarkup([[
            InlineKeyboardButton("üìã Menu ch√≠nh", callback_data="back_to_menu")
        ]])
    )

async def set_bot_commands(application: Application) -> None:
    """Set bot commands in menu"""
    commands = [
        ("start", "Kh·ªüi ƒë·ªông bot"),
        ("help", "Xem h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng"),
        ("menu", "Hi·ªÉn th·ªã menu ch·ª©c nƒÉng")
    ]
    await application.bot.set_my_commands(commands)

async def menu(update: Update, context: CallbackContext) -> None:
    """Show menu with inline keyboard buttons"""
    keyboard = [
        [
            InlineKeyboardButton("üì• H∆∞·ªõng d·∫´n t·∫£i", callback_data="guide"),
            InlineKeyboardButton("‚ÑπÔ∏è V·ªÅ bot", callback_data="about")
        ],
        [
            InlineKeyboardButton("üîó H·ªó tr·ª£ ƒë·ªãnh d·∫°ng", callback_data="formats"),
            InlineKeyboardButton("‚ùì Tr·ª£ gi√∫p", callback_data="help")
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        "üîç Ch·ªçn ch·ª©c nƒÉng b·∫°n mu·ªën s·ª≠ d·ª•ng:",
        reply_markup=reply_markup
    )

async def button_callback(update: Update, context: CallbackContext) -> None:
    """Handle button callbacks"""
    query = update.callback_query
    await query.answer()  # Acknowledge the button press

    if query.data == "guide":
        text = ("üì• *H∆∞·ªõng d·∫´n t·∫£i xu·ªëng:*\n\n"
                "1. Sao ch√©p link Instagram\n"
                "2. D√°n tr·ª±c ti·∫øp v√†o chat v·ªõi bot\n"
                "3. ƒê·ª£i bot x·ª≠ l√Ω v√† t·∫£i xu·ªëng\n\n"
                "_L∆∞u √Ω: Bot h·ªó tr·ª£ t·∫£i c√°c ƒë·ªãnh d·∫°ng sau:_\n"
                "‚Ä¢ B√†i ƒëƒÉng (Post)\n"
                "‚Ä¢ Video ng·∫Øn (Reel)\n"
                "‚Ä¢ Story (Stories)")

    elif query.data == "formats":
        text = ("üîó *C√°c ƒë·ªãnh d·∫°ng h·ªó tr·ª£:*\n\n"
                "‚Ä¢ B√†i ƒëƒÉng (Post)\n"
                "‚Ä¢ Video ng·∫Øn (Reel)\n"
                "‚Ä¢ Story (Stories)\n\n"
                "_C√≥ th·ªÉ d√πng link r√∫t g·ªçn ho·∫∑c ƒë·∫ßy ƒë·ªß_")

    elif query.data == "about":
        text = ("‚ÑπÔ∏è *Th√¥ng tin v·ªÅ Bot*\n\n"
                "‚Ä¢ T√™n: InstaGrap Bot\n"
                "‚Ä¢ Ch·ª©c nƒÉng: T·∫£i video, ·∫£nh t·ª´ Instagram\n"
                "‚Ä¢ H·ªó tr·ª£: Post, Reel, Story\n"
                "‚Ä¢ Phi√™n b·∫£n: 1.0\n\n"
                "_Bot ƒë∆∞·ª£c ph√°t tri·ªÉn b·ªüi @sytinhboy_")

    elif query.data == "help":
        text = await help_command(update, context, return_text=True)

    elif query.data == "back_to_menu":
        # Show menu when back button is clicked
        keyboard = [
            [
                InlineKeyboardButton("üì• H∆∞·ªõng d·∫´n t·∫£i", callback_data="guide"),
                InlineKeyboardButton("‚ÑπÔ∏è V·ªÅ bot", callback_data="about")
            ],
            [
                InlineKeyboardButton("üîó H·ªó tr·ª£ ƒë·ªãnh d·∫°ng", callback_data="formats"),
                InlineKeyboardButton("‚ùì Tr·ª£ gi√∫p", callback_data="help")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            text="üîç Ch·ªçn ch·ª©c nƒÉng b·∫°n mu·ªën s·ª≠ d·ª•ng:",
            reply_markup=reply_markup
        )
        return

    # Only add back button for non-menu screens
    await query.edit_message_text(
        text=text,
        parse_mode='Markdown',
        reply_markup=InlineKeyboardMarkup([[
            InlineKeyboardButton("‚Ü©Ô∏è Quay l·∫°i Menu", callback_data="back_to_menu")
        ]])
    )

async def about_command(update: Update, context: CallbackContext) -> None:
    """Send information about the bot when the command /about is issued."""
    text = ("‚ÑπÔ∏è *Th√¥ng tin v·ªÅ Bot*\n\n"
            "‚Ä¢ T√™n: InstaGrap Bot\n"
            "‚Ä¢ Ch·ª©c nƒÉng: T·∫£i video, ·∫£nh t·ª´ Instagram\n"
            "‚Ä¢ H·ªó tr·ª£: Post, Reel, Story\n"
            "‚Ä¢ Phi√™n b·∫£n: 1.0\n\n"
            "_Bot ƒë∆∞·ª£c ph√°t tri·ªÉn v·ªõi m·ª•c ƒë√≠ch phi l·ª£i nhu·∫≠n_")

    await update.message.reply_text(
        text,
        parse_mode='Markdown',
        reply_markup=InlineKeyboardMarkup([[
            InlineKeyboardButton("üìã Menu ch√≠nh", callback_data="back_to_menu")
        ]])
    )

async def main() -> None:
    """Start the bot."""
    # Initialize Instagram client
    if not init_instagram_client():
        logger.error("Failed to initialize Instagram client")
        return

    # Create the Application
    application = Application.builder().token(Config.TOKEN).build()

    # Add handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("menu", menu))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, process_instagram_url))
    application.add_handler(CallbackQueryHandler(button_callback))

    # Set bot commands
    await set_bot_commands(application)
    await application.run_polling()

    # Start the bot
    logger.info("Starting bot...")

import nest_asyncio
nest_asyncio.apply()

if __name__ == "__main__":
    asyncio.run(main())
